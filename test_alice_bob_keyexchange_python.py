from ecdsa import ECDH, SigningKey, VerifyingKey, SECP128r1

# For quick testing purposes, Alice keypairs and Bob keypairs are generated
# within this file. In reality, both of them are on their own devices, hence
# none of them can see each other private key.

# generate Alice keypairs, return value is the private key
alice_sk = SigningKey.generate(curve=SECP128r1)
print('Alice private: ' + alice_sk.to_string().hex())

# get Alice public key
alice_vk = alice_sk.verifying_key
print('Alice public : ' + alice_vk.to_string().hex())

alice_ecdh = ECDH(curve=SECP128r1)
alice_ecdh.load_private_key(alice_sk)

# generate Bob keypairs, return value is the private key
bob_sk = SigningKey.generate(curve=SECP128r1)
print('Bob private: ' + bob_sk.to_string().hex())

# get the public key
bob_vk = bob_sk.verifying_key
print('Bob public : ' + bob_vk.to_string().hex())

bob_ecdh = ECDH(curve=SECP128r1)
bob_ecdh.load_private_key(bob_sk)

# IMPORTANT NOTE: There is no secure way of sending a public key from one end
# to another. You can sign it to detect if it has been altered, but the man-in
# -the-middle attack would likely to alter both signature and public key.
# In short you need a mechanism to validate that the public key is trusted,
# otherwise the digital signature will not increase the security level.

# Public key shall be obtained from a truststore, like the one generated by
# 123MQTT and you can verify it at any time. This is the case when you sign up
# to https://123mqtt.com and you get both initial private and public keys under
# user profile.

# After this point, it is assumed that public keys exchange already happened,
# obtained from a trusted party, like 123MQTT. Each party can now generate the
# shared secret.

# Alice generates the shared secret when Bob's public key is obtained
alice_received_public_key = bob_vk.to_string().hex()
alice_ecdh.load_received_public_key_bytes(bytearray.fromhex(alice_received_public_key))
alice_secret = alice_ecdh.generate_sharedsecret_bytes()
print("Shared secret generated on Alice's end:" + alice_secret.hex())

# Bob generates the shared secret when Alice's public key is obtained
bob_received_public_key = alice_vk.to_string().hex()
bob_ecdh.load_received_public_key_bytes(bytearray.fromhex(bob_received_public_key))
bob_secret = bob_ecdh.generate_sharedsecret_bytes()
print("Shared secret generated on Bob's end:" + bob_secret.hex())

# The shared secret should be identical and can now be used for encryption
if (alice_secret == bob_secret):
    print('Shared secret identical')
else:
    print('Shared secret is not identical')